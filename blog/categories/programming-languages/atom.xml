<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming languages | Thomas Whitton]]></title>
  <link href="http://www.thomaswhitton.com/blog/categories/programming-languages/atom.xml" rel="self"/>
  <link href="http://www.thomaswhitton.com/"/>
  <updated>2014-01-26T19:46:08+00:00</updated>
  <id>http://www.thomaswhitton.com/</id>
  <author>
    <name><![CDATA[Thomas Whitton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[My Perfect Programming Language From Scratch]]></title>
    <link href="http://www.thomaswhitton.com/blog/2014/01/07/my-perfect-programming-language-from-scratch/"/>
    <updated>2014-01-07T01:27:57+00:00</updated>
    <id>http://www.thomaswhitton.com/blog/2014/01/07/my-perfect-programming-language-from-scratch</id>
    <content type="html"><![CDATA[<p>After taking the Programming Languages Course from Courser and learning a couple of new languages recently I&rsquo;ve found myself really looking at the beauty of programming languages and wanted to spend a little time coming up with my own perfect language from scratch. To start off I will not worry about implementation details, this will allow me to concentrate on the language itself rather than coding challenges. Eventually I hope to create a minimal implementation to try out my new language.</p>

<!-- more -->


<h2>Paradigms</h2>

<p>I think it will be good to start with some simple paradigms of the language, which I will go through now with some basic reasoning behind each.</p>

<p>Having a <strong>statically typed</strong> language is very helpful in catching bugs that would otherwise be missed in a dynamic language. It also allows much better tooling to be created around that language such as code analysers. The only problem with it is the amount of verbosity that comes with writing the code, this can be heavily offset with a <strong>global type inference</strong> system that means that most type declarations are no longer needed (but can be optionally added for readability). In fact it should be possible to only ever use a type declaration when creating a class, this includes a very useful and comprehensive set of type literals.</p>

<p>It has been shown in pretty much every other language (especially in functional, as per the name) to be able to pass functions around as if they were like variables, including functions that have already had some of their arguments passed in. To this end all language will provide <strong>first class functions</strong>. To accomplish this with minimal specialising of the language for functions, the functions will be made to be an object and in fact the language will take the <strong>object orientated</strong> approach of everything is an object.</p>

<p>I really enjoy programming in c++, and being in control of the system as much as possible, however, I still will use smart pointers as much as I can to avoid worrying about memory. I think nowadays any implementation of a language should be smart enough to be able to efficiently deal with memory, and allow the programmer to worry about more important things, and as such this language will have <strong>managed memory</strong>.</p>

<p>I won&rsquo;t bother reiterating the countless posts and discussions about how allowing mutability of variables leads to problems within a language. But I will mention that I believe having <strong>immutability by default</strong> can make some pretty interesting efficient data structures. I also understand the need for being able to have mutable variables occasionally, but I agree with with SML approach for this, and that is that you have to <strong>explicitly declare a mutable variable</strong> and that <strong>only allow the reference to be mutable and it will just be able to point to an entirely different object</strong>.</p>

<p>Lastly just a few little additions that I have found very useful, and that is having <strong>if statements as expressions</strong> which allows for some very neat code, <strong>tail call optimization</strong>, and <strong>lexicographically scoped</strong>.</p>

<h2>General Syntax</h2>

<p>After recently learning and programming in my first lisp/scheme, I really loved the simplicity of the syntax, however, I felt like it went slightly too far, and made it harder for programmers to understand at a glance what was happening. To that end I believe that having as <strong>minimal syntax</strong> as possible, and therefore a <strong>minimal set of keywords</strong> without decreasing the readability of code is a worthwhile goal.</p>

<ul>
<li>C like.</li>
<li>Semicolons separate expressions.</li>
<li>White space doesn&rsquo;t matter, except that new lines can separate expressions rather than using semicolons.</li>
<li>Scope using curly brackets.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Coursera Course Reviews]]></title>
    <link href="http://www.thomaswhitton.com/blog/2014/01/06/coursera-course-reviews/"/>
    <updated>2014-01-06T00:01:34+00:00</updated>
    <id>http://www.thomaswhitton.com/blog/2014/01/06/coursera-course-reviews</id>
    <content type="html"><![CDATA[<p>Lately I have been really interested in participating in some of the programming related massive open online courses (MOOCs) offered by <a href="https://www.coursera.org/">Coursera</a>. Coursera offers a really great platform for learning; providing multiple ways to test students' understanding of the material and also most importantly a large community of like minded people in the Coursera discussion forums providing invaluable help to others.</p>

<!-- more -->


<h2><a href="https://www.coursera.org/course/progfun">Functional Programming Principles in Scala</a></h2>

<p>This course was my first introduction to functional programming apart from the useful functional helper methods and various other techniques that have seeped into most high-level languages. This was also my first time using Scala, which I had been meaning to try out for a while now. I really enjoyed the Scala language, but a lot of the course involved learning some of the basics of the language rather than learning functional programming. The course was very similar to the amazing Structure and Interpretation of Computer Programs (SICP) book, used in many university courses, but using Scala instead of Scheme. I found the course material very useful and it has actually given me the desire to work with Scala in the future.</p>

<p>I found the material easy to grasp and the exercises were relatively simple, the one thing that I did take a little bit more time was that I was trying to make my answers to the exercises into beautiful one line solutions (once you go functional&hellip;).</p>

<h2><a href="https://www.coursera.org/course/proglang">Programming Languages</a></h2>

<p>This course covers a lot of different material in programming language theory: static functional (using SML), dynamic functional (using racket, a scheme) and dynamic object orientation (using ruby). The functional part was a very good introduction to functional programming, SML was such a simple language that we could spend most of the time learning about functional programming rather than quirks of the language. In the next section I really liked learning about the simplicity of a scheme. Personally though I feel that it is too hard for a programmer to quickly understand code with so many brackets. As someone who has done a lot of object orientated programming (OOP) previously, I found the OOP part of the course to be a lot easier than the rest. But obviously if I were to come into the course with no experience of OOP then I probably would have found it the same level of difficulty as the rest of the course. The entire course was very interesting and has made me much more interested in programming language design, and to learn many more programming paradigms in other languages.</p>

<p>I found the assignments quite challenging, especially towards the end of the course. The grading policy was also quite strict, giving you an average of your first two submissions. One different aspect to the course compared to most other courses was that there was a peer review section, I found this particularly useful as I believe it made me more deeply understand the common problems that occur and also it provided a sample solution which was very useful in checking if you had completed assignments correctly.</p>

<h2><a href="https://www.coursera.org/course/ml">Machine Learning</a></h2>

<p>This is the fundamental machine learning course that has been provided openly by Standford for a while now, and was one of the first available courses on Coursera. It taught many of the essential techniques for machine learning, which I found quite easy to grasp, as most of the ideas were common sense converted into maths and computational algorithms. I think this course has given me a better grasp on what machine learning actually is, as well as all the terminology associated with it. Also how I can use pretty simple techniques to actually analyze large sets of data very quickly and to great effect. With this information under my belt I believe I can handle a complex machine learning project, that uses techniques well beyond that of the course, with only a little bit of googling.</p>

<p>Octave was used for the programming language and I can understand why, as it made the programming exercises very easy to accomplish and meant that you only had to worry about the machine learning techniques rather than the code.</p>

<h2><a href="https://www.coursera.org/course/reactive">Principles of Reactive Programming</a></h2>

<p>This was a brand new course offered by Coursera as a sequel to the very popular &ldquo;Functional Programming Principles in Scala&rdquo; course mentioned previously, although it was not as polished as its predecessor. However, I really enjoyed learning about some of the advanced techniques in reactive programming. I thought the discussion on monads was very good and I really liked learning about the actor model and I think it was very easy to grasp from the lectures. Especially being able to use it with <a href="http://akka.io/">akka</a>, which is a very mature actor framework for the JVM. I found a lot of the Future/Promises lectures slightly too theoretical, it was fine once I actually used it in the programming exercises, however, a lot of it blew my mind a little bit during the videos.</p>

<p>I found the exercises very rewarding, as they really delved deep into modern reactive frameworks at the cutting edge of programming. Not only that but being able to write more complicated scala considerably deepened my interest in the language. I feel that with a few more iterations of the course, and taking into account the comments from students, that this course will become as popular and fundamental as its predecessor.</p>

<p>For the new year I am taking <a href="https://www.coursera.org/course/comnetworks">Computer Networks</a>, <a href="https://www.coursera.org/course/crypto">Cryptography 1</a> and <a href="https://www.coursera.org/course/android">Programming Mobile Applications for Android Handheld Systems</a>, which all look to be interesting and useful courses. I encourage you to use Coursera to develop your abilities, as I believe that as programmers we should never stop learning.</p>
]]></content>
  </entry>
  
</feed>
